#include <bits/stdc++.h>
#include <grid.h>

using namespace std;

template <typename T>
using min_heap = priority_queue<T, std::vector<T>, std::greater<T>>;

namespace algo {
bool dfs(Grid initial_state);

// naive dijkstra / ucs implementation
bool dijkstra(Grid &state, vector<vector<int>> dis, set<string> &visited,
              vector<Grid> &solution);

// bool optimised_dijkstra(pair<int, int> src, Grid state, vector<vector<int>>
// dis,
//                         set<string> visited, vector<Grid> &solution) {
//   if (state.is_solved()) {
//     return true;
//   }
//
//   string state_str = state.to_string();
//   if (visited.find(state_str) != visited.end()) {
//     return false;
//   }
//
//   visited.emplace(state_str);
//
//   min_heap<pair<int, pair<int, int>>> pq;
//   pq.emplace(pair(0, pair(src.first, src.second)));
//   while (!pq.empty()) {
//     auto top = pq.top();
//     pq.pop();
//     min_heap<pair<int, pair<pair<int, int>, Grid>>> moves;
//     for (int i = 0; i < dis.size(); ++i) {
//       for (int j = 0; j < dis[0].size(); ++j) {
//         if (state.is_empty(i, j)) {
//           if (int wgt = dis[src.first][src.second] + 1; wgt < dis[i][j]) {
//             dis[i][j] = wgt;
//             pq.emplace(pair(dis[i][j], pair(i, j)));
//             Grid next_state = state;
//             next_state.move(src.first, src.second, i, j);
//             moves.emplace(next_state.filled(), next_state);
//           }
//         }
//       }
//     }
//     // while (!moves.empty()) {
//     //   auto [filled, state] = moves.top();
//     //   pq.pop();
//     //   if (optimised_dijkstra(pair(i, j), state, dis, visited)) {
//     //     solution.emplace_back(state);
//     //   }
//     // }
//   }
//   return false;
// }

} // namespace algo
